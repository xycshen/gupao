单例模式：懒汉，饿汉，双重校验锁，枚举和静态内部类。
ThreadLocal伪单例，线程内安全非全局线程安全
1.饿汉模式
    优：天然的线程安全，在类装载的时候就完成实例化。避免了线程同步问题。
    缺：在类装载的时候就完成实例化，没有达到Lazy Loading的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费。启动慢。
    避免序列化和反序列化，必须实现readResolve() 方法

2.懒汉模式
    优：实现了延迟加载效果。
    缺：解决线程不安全问题，效率太低，

3.双重校验锁  【推荐使用】
   优：线程安全；延迟加载；效率较高。

4.静态内部类  【推荐使用】
   优：静态内部类方式在Singleton类被装载时并不会立即实例化，而是在需要实例化时，调用getInstance方法，
      才会装载SingletonInstance类，完成Singleton的实例化。
       避免了线程不安全，延迟加载，效率高（未使用synchronized）。

5.枚举        【推荐使用】
    JDK1.5中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。
    jdk底层实现线程安全机制


2、思考破坏单例模式的方式有哪些？并且归纳总结。
    1.反射机制
      解决方法，在私有构造函数里判断是否初始化，否则抛出异常，无法创建实例。
    2.序列化，反序列化。
       解决方法,实现readResolve() 方法。
